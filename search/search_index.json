{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Official Fujihack Wiki This wiki documents the internals of Fujifilm cameras (both hardware and software) that enables Fujihack to achieve its goals. It also has some info about Fujihack development: Project structure Camera hacking vocab The wiki is made with MKDocs, and you can make edits through Github: https://github.com/fujihack/fujihack.github.io Public Fujihack Google spreadsheet . FujiHack is licensed under the GNU General Public License v3.0. This project is not affiliated with or endorsed by Fujifilm or any other group. The source code is open source and hosted on Github .","title":"Home"},{"location":"#official-fujihack-wiki","text":"This wiki documents the internals of Fujifilm cameras (both hardware and software) that enables Fujihack to achieve its goals. It also has some info about Fujihack development: Project structure Camera hacking vocab The wiki is made with MKDocs, and you can make edits through Github: https://github.com/fujihack/fujihack.github.io Public Fujihack Google spreadsheet . FujiHack is licensed under the GNU General Public License v3.0. This project is not affiliated with or endorsed by Fujifilm or any other group. The source code is open source and hosted on Github .","title":"Official Fujihack Wiki"},{"location":"autoactscr/","text":"Auto Activated Script AUTO_ACT.SCR is a script that is stored on the SD card in the DCAA folder. DCAA stands for Digital Camera Auto Act. This script has been with the Fujifilm cameras since 2004 , and is still included on modern cameras. Activation The script is executed by the mujin task. See tasks . The script is only activated when byte 0xa2 in EEPROM is set to 2 . It's activated when the camera turns on, just before the menus initialize Rules Files absolutely must use Windows style line breaks ( \\n\\r ). Else, the lexer will hang. Comments start with // Each token can be no more than 20 characters long. Each line can have up to 10 tokens Keywords are case sensitive. ' ', '\\r', and '\\t' are whitespace characters. Keywords if func key calc set jump random tp LABEL END WAITSET WT_LOG if The 5th parameter is only for decoration. The interpreter never checks it. It could be any valid token. Supported operations: != , <= , >= , and == . if x == 10 jump label calc The = or 3rd parameter is again, only for decoration. & , - , * , + , and / are supported math operations. calc x = x + 1 calc x = 123 & 6 jump Jump to a label. jump label LABEL Won't work if lowercase. LABEL top WT_LOG Creates a function that makes DSCFXXXX.MSG log file in DCIM Nothing significant, writes some UI logs in a binary format. Maybe Syslog format? Accepts a parameter, but seems to never be used. WT_LOG END Ends the script key Triggers a key press First parameter can be MODE or a button key name. Second parameter can be ON or OFF // Disconnect USB key USB OFF // Press UP key key UP ON random Random between two numbers random x 0 10 wait wait x miliseconds wait 2000 WAITSET Creates a delay between each command in the script, in miliseconds. WAITSET 0x1234 Types: EEPROM type Starts with E_ , and follows is 4 hexadecimal numbers Can be used to either set or get a byte from EEPROM. set x = E_a2 set E_9999 = 123 Integer Can be 5 bytes long 123 Hexadecimal Must be lower case Can only be 4 bytes long 0x123 0xa1 Functions TODO: more research ON OFF MOVE SWEEP 2ON 2OFF 2MOVE 2SWEEP MULTI Examples Count to 10 set x = 1 LABEL lab if x >= 10 jump end calc x = x + 1 jump lab LABEL end","title":"AUTO ACT script"},{"location":"autoactscr/#auto-activated-script","text":"AUTO_ACT.SCR is a script that is stored on the SD card in the DCAA folder. DCAA stands for Digital Camera Auto Act. This script has been with the Fujifilm cameras since 2004 , and is still included on modern cameras.","title":"Auto Activated Script"},{"location":"autoactscr/#activation","text":"The script is executed by the mujin task. See tasks . The script is only activated when byte 0xa2 in EEPROM is set to 2 . It's activated when the camera turns on, just before the menus initialize","title":"Activation"},{"location":"autoactscr/#rules","text":"Files absolutely must use Windows style line breaks ( \\n\\r ). Else, the lexer will hang. Comments start with // Each token can be no more than 20 characters long. Each line can have up to 10 tokens Keywords are case sensitive. ' ', '\\r', and '\\t' are whitespace characters.","title":"Rules"},{"location":"autoactscr/#keywords","text":"if func key calc set jump random tp LABEL END WAITSET WT_LOG","title":"Keywords"},{"location":"autoactscr/#if","text":"The 5th parameter is only for decoration. The interpreter never checks it. It could be any valid token. Supported operations: != , <= , >= , and == . if x == 10 jump label","title":"if"},{"location":"autoactscr/#calc","text":"The = or 3rd parameter is again, only for decoration. & , - , * , + , and / are supported math operations. calc x = x + 1 calc x = 123 & 6","title":"calc"},{"location":"autoactscr/#jump","text":"Jump to a label. jump label","title":"jump"},{"location":"autoactscr/#label","text":"Won't work if lowercase. LABEL top","title":"LABEL"},{"location":"autoactscr/#wt_log","text":"Creates a function that makes DSCFXXXX.MSG log file in DCIM Nothing significant, writes some UI logs in a binary format. Maybe Syslog format? Accepts a parameter, but seems to never be used. WT_LOG","title":"WT_LOG"},{"location":"autoactscr/#end","text":"Ends the script","title":"END"},{"location":"autoactscr/#key","text":"Triggers a key press First parameter can be MODE or a button key name. Second parameter can be ON or OFF // Disconnect USB key USB OFF // Press UP key key UP ON","title":"key"},{"location":"autoactscr/#random","text":"Random between two numbers random x 0 10","title":"random"},{"location":"autoactscr/#wait","text":"wait x miliseconds wait 2000","title":"wait"},{"location":"autoactscr/#waitset","text":"Creates a delay between each command in the script, in miliseconds. WAITSET 0x1234","title":"WAITSET"},{"location":"autoactscr/#types","text":"","title":"Types:"},{"location":"autoactscr/#eeprom-type","text":"Starts with E_ , and follows is 4 hexadecimal numbers Can be used to either set or get a byte from EEPROM. set x = E_a2 set E_9999 = 123","title":"EEPROM type"},{"location":"autoactscr/#integer","text":"Can be 5 bytes long 123","title":"Integer"},{"location":"autoactscr/#hexadecimal","text":"Must be lower case Can only be 4 bytes long 0x123 0xa1","title":"Hexadecimal"},{"location":"autoactscr/#functions","text":"TODO: more research ON OFF MOVE SWEEP 2ON 2OFF 2MOVE 2SWEEP MULTI","title":"Functions"},{"location":"autoactscr/#examples","text":"","title":"Examples"},{"location":"autoactscr/#count-to-10","text":"set x = 1 LABEL lab if x >= 10 jump end calc x = x + 1 jump lab LABEL end","title":"Count to 10"},{"location":"eep/","text":"EEPROM Table Offset Desc 0xa2 AUTO_ACT.SCR boot flag 0xb6 TGKAI tgdata and modedata.txt flag (imgdc) 0x1e8 Software version first 0x1e9 Software version second 0x1ea EEP Date month 0x1eb EEP Date day 0x1ec - 0x1fb 'Script version' (XF10F_e_19.fs)","title":"EEPROM Table"},{"location":"eep/#eeprom-table","text":"Offset Desc 0xa2 AUTO_ACT.SCR boot flag 0xb6 TGKAI tgdata and modedata.txt flag (imgdc) 0x1e8 Software version first 0x1e9 Software version second 0x1ea EEP Date month 0x1eb EEP Date day 0x1ec - 0x1fb 'Script version' (XF10F_e_19.fs)","title":"EEPROM Table"},{"location":"exif/","text":"IMFIDX10 IMxxxxxxxxxx directories are described in the 1998 JEIDA (Japan Electronic Industry Development Association) patent IMxxxxxxxxxx are referred to as an 'Exif directory'. Exif directories can store Exif files. It's difficult to understand exactly what the paper says, but it's clear that this folder is used for general purpose file (image, sound, video) manipulation. In Fujifilm cameras, an S3 file is stored in the IMFIDX10 directory. For the XF1, it is C:\\IMFIDX10\\XF10RS.S3 . In the JEIDA paper, IMFIDX10 is described as a 'self-recorded Exif directory'. S3 files are standard Motorola S-record files . Fujifilm has a long history of using these files. On cameras from the early 2000s, they were used to apply early firmware updates . These files appear on Fujifilm cameras as far back as the S3 Pro to the XH2S ( C:\\IMFIDX10\\LX46.S ). See /etc/s3 for a lousy attempt to understand S3 files. The S3 file reader seems to apply patches to EEPROM (possibly allowing script execution, TGKAI stuff), and possibly write bytes to RAM or flash memory. It is called by a function table handler that can be traced back to the usbcont task. This means it could possibly be triggered via USB. It's impossible to tell because of how cryptic the RTOS is.","title":"IMFIDX10"},{"location":"exif/#imfidx10","text":"IMxxxxxxxxxx directories are described in the 1998 JEIDA (Japan Electronic Industry Development Association) patent IMxxxxxxxxxx are referred to as an 'Exif directory'. Exif directories can store Exif files. It's difficult to understand exactly what the paper says, but it's clear that this folder is used for general purpose file (image, sound, video) manipulation. In Fujifilm cameras, an S3 file is stored in the IMFIDX10 directory. For the XF1, it is C:\\IMFIDX10\\XF10RS.S3 . In the JEIDA paper, IMFIDX10 is described as a 'self-recorded Exif directory'. S3 files are standard Motorola S-record files . Fujifilm has a long history of using these files. On cameras from the early 2000s, they were used to apply early firmware updates . These files appear on Fujifilm cameras as far back as the S3 Pro to the XH2S ( C:\\IMFIDX10\\LX46.S ). See /etc/s3 for a lousy attempt to understand S3 files. The S3 file reader seems to apply patches to EEPROM (possibly allowing script execution, TGKAI stuff), and possibly write bytes to RAM or flash memory. It is called by a function table handler that can be traced back to the usbcont task. This means it could possibly be triggered via USB. It's impossible to tell because of how cryptic the RTOS is.","title":"IMFIDX10"},{"location":"firmware/","text":"Firmware Patching The firmware payload is bit-flipped ( ~ ). The checksum is a simple case of \"add up all the bytes and make sure it equals X\" Header struct FujiFirmHeader { // Type of the firmware layout - shows parser how big MODEL_CODE_SIZE is unsigned int type; // Proprietary model ID code unsigned char code[MODEL_CODE_SIZE]; // Printed as hex in the camera. X.X unsigned int version1; unsigned int version2; // File checksum unsigned int checksum; // Whether device is a lens or camera unsigned int device_type; }; Dangerous? Firmware patching is always dangerous no matter what. A small typo can brick the entire camera. When I first started the project, I bought the cheapest camera I could find, to test if patching was possible, and what if it were possible to run custom code on it. Somewhere in my experiments I accidentally deleted a number off an address, and the camera no longer showed any signs of life. It was a bummer, but I had prepared for it. That was with a few janky Makefiles and C scripts. The new Javascript patcher has sanity checks that verify checksums and instructions around the injection point. It's much safer, and I've probably tested it around 100 times or so. But it's still very dangerous. My personal advice is that you don't try custom firmware on any piece of technology worth more than $1000. However, sometimes the rewards outweight the risks. It is most likely possible to recover a bricked camera, through the boot ROM, burned into the SoC. Reverse engineering this takes a lot of time, skill, and money, so it hasn't been figured out as of mid 2023.","title":"Firmware Patching"},{"location":"firmware/#firmware-patching","text":"The firmware payload is bit-flipped ( ~ ). The checksum is a simple case of \"add up all the bytes and make sure it equals X\"","title":"Firmware Patching"},{"location":"firmware/#header","text":"struct FujiFirmHeader { // Type of the firmware layout - shows parser how big MODEL_CODE_SIZE is unsigned int type; // Proprietary model ID code unsigned char code[MODEL_CODE_SIZE]; // Printed as hex in the camera. X.X unsigned int version1; unsigned int version2; // File checksum unsigned int checksum; // Whether device is a lens or camera unsigned int device_type; };","title":"Header"},{"location":"firmware/#dangerous","text":"Firmware patching is always dangerous no matter what. A small typo can brick the entire camera. When I first started the project, I bought the cheapest camera I could find, to test if patching was possible, and what if it were possible to run custom code on it. Somewhere in my experiments I accidentally deleted a number off an address, and the camera no longer showed any signs of life. It was a bummer, but I had prepared for it. That was with a few janky Makefiles and C scripts. The new Javascript patcher has sanity checks that verify checksums and instructions around the injection point. It's much safer, and I've probably tested it around 100 times or so. But it's still very dangerous. My personal advice is that you don't try custom firmware on any piece of technology worth more than $1000. However, sometimes the rewards outweight the risks. It is most likely possible to recover a bricked camera, through the boot ROM, burned into the SoC. Reverse engineering this takes a lot of time, skill, and money, so it hasn't been figured out as of mid 2023.","title":"Dangerous?"},{"location":"history/","text":"Fujifilm's Tech History History In 1988, Fujifilm released their first 0.4mp digital camera, the Fujix DS-1P (first commercial digital camera) Fuji released the $3500 Fujifilm S1 Pro in 2000, which accepted firmware updates In 2003, Fujifilm first released a firmware update and hackers on DPReview started to tinker with it Fujifilm started out using VxWorks, then later switched to MiSPO iTRON/NORTi More modern cameras use ThreadX, an open source RTOS. Many pieces of the original 2003 Fujifilm code is still present. SQLite was introduced in ~2012 to manage special settings in the camera. SQLite starts up about 10 minutes after powering on. In 2016-2017, a web server and networking drivers were introduced into the firmware, for WiFi connectivity (wpa_supplicant) In 2022, Linux is booted on the X-H2S for WiFi and processing functionality. To this day, Fujifilm continues to use most of the original firmware code from the early 2000s. CPUs Early Fujifilm cameras started out with 64 bit TX49 MIPS III CPUs but switched to 32 bit ARM later on Smaller cameras have the FF4224 SoC, but there is also a FF4226. These appear to be ARM v6 CPUs. Recently, Fujifilm started compiling their firmware in thumb bytecode. The SoC has no internal memory and must be paired with external RAM chips (1gb is common) Flash chips tend to be under the SD card reader (and tend to be 64mb)","title":"History overview"},{"location":"history/#fujifilms-tech-history","text":"","title":"Fujifilm's Tech History"},{"location":"history/#history","text":"In 1988, Fujifilm released their first 0.4mp digital camera, the Fujix DS-1P (first commercial digital camera) Fuji released the $3500 Fujifilm S1 Pro in 2000, which accepted firmware updates In 2003, Fujifilm first released a firmware update and hackers on DPReview started to tinker with it Fujifilm started out using VxWorks, then later switched to MiSPO iTRON/NORTi More modern cameras use ThreadX, an open source RTOS. Many pieces of the original 2003 Fujifilm code is still present. SQLite was introduced in ~2012 to manage special settings in the camera. SQLite starts up about 10 minutes after powering on. In 2016-2017, a web server and networking drivers were introduced into the firmware, for WiFi connectivity (wpa_supplicant) In 2022, Linux is booted on the X-H2S for WiFi and processing functionality. To this day, Fujifilm continues to use most of the original firmware code from the early 2000s.","title":"History"},{"location":"history/#cpus","text":"Early Fujifilm cameras started out with 64 bit TX49 MIPS III CPUs but switched to 32 bit ARM later on Smaller cameras have the FF4224 SoC, but there is also a FF4226. These appear to be ARM v6 CPUs. Recently, Fujifilm started compiling their firmware in thumb bytecode. The SoC has no internal memory and must be paired with external RAM chips (1gb is common) Flash chips tend to be under the SD card reader (and tend to be 64mb)","title":"CPUs"},{"location":"keys/","text":"Key ID Official Key Name Note 1 EXE_M Menu/OK Button 2 UP ... 3 DOWN ... 4 LEFT ... 5 RIGHT ... 6 POWER ... 7 S1 Shutter half pressed 8 S2 shutter full pressed 13 BARR_OP ... 14 BARR_CL ... 12 BARRIER ... 520 CRADLE ... 15 ADAPTER ... 16 USB Turning key off turns off PTP/USB 516 DOOR ... 17 CARD ... 10 FMODE ... 18 EXP ... 19 METER ... 22 TELE2 ... 23 WIDE2 ... 20 TELE ... 21 WIDE ... 24 AF ... 25 VIDEO ... 26 HDTV ... 27 CONT ... 785 AS_MODE ... 9 DISP_B ... 45 K_HOME ... 11 K_PLAY ... 517 FACE ... 521 CRD_P ... 522 CRD_U ... 513 MET_SP ... 515 MET_AV ... 514 MET_MU ... 50 HVS_0 ... 51 HVS_90 ... 52 HVS_180 ... 53 HVS_270 ... 28 POP ... 29 C_DIAL+ ... 30 C_DIAL- ... 31 W_DIAL+ ... 32 W_DIAL- ... 33 MF_AF_A ... 34 MF_AF_C ... 35 MF_AF_M ... 36 1P_AF+ ... 39 F_RING+ ... 40 F_RING- ... 37 Z_RING+ ... 38 Z_RING- ... 41 AE-LOCK ... 42 EVF_LCD ... 43 INFO ... 527 AEAF_LOCK ... 528 WB ... 519 K_PS ... 523 AE ... 524 VIEW ... 525 RAW ... 48 EVF_OVF ... 518 MACRO ... 58 CMD_PUSH ... 59 CMD_LEFT ... 60 CMD_RIGHT ... 46 MOVIE_REC ... 526 EYE_SEN ... 55 RING_OFF ... 56 RING_STB ... 57 RING_ON ... 54 FUNCTION2 ... 47 FUNCTION ... 768 PLAY ... 769 REC ... 770 AUTO ... 771 QUICK ... 772 SP ... 773 SP2 ... 774 SR ... 775 PORTRAIT ... 776 LANDSCAPE ... 777 SPORTS ... 778 NIGHT ... 780 BLURRE ... 779 NATURAL ... 782 PROGRAM ... 783 SHUTTER ... 784 APERTURE ... 786 MANUAL ... 781 N_FLASH ... 791 C1 ... 792 C2 ... 793 C3 ... 794 FSB ... 44 ISO ... 796 ADVANCE ... 789 SETUP ... 786 M_SEL ... 787 VOICE ... 788 MOVIE ... 825 JIG ... 795 EXR ... 787 VREC ... 788 MJPEG ... 772 SCEN_P ... 772 SCEN_S ... 782 MMOD_P ... 783 MMOD_S ... 784 MMOD_A ... 786 MMOD_M ... 18 APERT ...","title":"Key codes"},{"location":"license/","text":"FujiHack is licensed under GPL 3.0","title":"License"},{"location":"patcher/","text":"Fujihack patcher has been moved You can find the source code here","title":"Patcher"},{"location":"ptp/","text":"List of PTP Optcodes See ptp.h Also see @malc0mn's pip-ip library in Go . camlib attempts to have a complete implementation of Fujifilm's PTP/IP protocol 0x1001-0x100B, 0x100F, 0x1014, 0x1015, 0x1016, 0x101B Fujifilm commands: 0x900C, 0x900D, 0x901D Microsoft commands: 0x9801, 0x9802, 0x9803, 0x9805 Vendor specific commands can be used to upload firmware files to the camera 0x900C Create file 0x900D Possibly for sending file info 0x901D Write to file These might be sligtly modified versions of 0x100C, 0x100D, and 100B (?) Either way, they are very similar.","title":"PTP/USB"},{"location":"ptp/#list-of-ptp-optcodes","text":"See ptp.h Also see @malc0mn's pip-ip library in Go . camlib attempts to have a complete implementation of Fujifilm's PTP/IP protocol 0x1001-0x100B, 0x100F, 0x1014, 0x1015, 0x1016, 0x101B Fujifilm commands: 0x900C, 0x900D, 0x901D Microsoft commands: 0x9801, 0x9802, 0x9803, 0x9805 Vendor specific commands can be used to upload firmware files to the camera","title":"List of PTP Optcodes"},{"location":"ptp/#0x900c","text":"Create file","title":"0x900C"},{"location":"ptp/#0x900d","text":"Possibly for sending file info","title":"0x900D"},{"location":"ptp/#0x901d","text":"Write to file These might be sligtly modified versions of 0x100C, 0x100D, and 100B (?) Either way, they are very similar.","title":"0x901D"},{"location":"rtos/","text":"Technical overview of Fujifilm's Firmware (These details come from reverse-engineering the firmware of the X-A2.) Fujifilm started working on their firmware in the early 2000s. Instead of writing their firmware directly on an RTOS, they made a compatibility layer over an existing RTOS. This allowed them to easily switch from VxWorks to NORTi and to ThreadX over the years. Each function in Fuji's compatibility layer calls a specific index of a function table, which makes reverse engineering or using the underlying RTOS very difficult. Instead, this project aims to reverse engineer only Fujifilm's compatibility layer instead. Fujifilm's I/O API See ff_io.h Memory management Unlike most firmware, Fujifilm doesn't have a malloc() function. Each task works with fixed empty arrays. The developers created huge global variables. This means a lot of RAM is wasted, and it makes it harder to load Fujihack. There are some allocation functions, such as the ones from SQLite or the WiFi code, but these only offer a megabyte or two and don't take advantage of all the RAM the camera has (1GB). This unusual memory management has both pros and cons for the Fujihack project. - Patching data is easier - since everything is a global variable, a fixed address can be used to specify any data - It's hard to load a large Fujihack binary - Since memory can't be easily allocated, this makes it hard to find space to load Fujihack. Overall, it's not a deal breaker. Fujifilm managed to make it work over the years, and Fujihack can find ways around it. Performance Fujifilm cameras up to 2016 are really slow. The CPU is underclocked to preserve battery life, which makes the camera sluggish sometimes. This doesn't take a toll on things like JPEG encoding and decoding, because it's done through hardware. The CPU performance of the X-A2 is similar to an i386 desktop computer of the mid 90s. After 2016, Fujifilm did something that improved performance. Or, at least the menu performance. Graphics Vector graphics processing is handled on vglib task Most cameras use OpenVG with the VG_KHR_EGL_image plugin. Implemented into Fuji cameras by NEC Systems Technology Ltd in the 2000s. The rst task renders the OpenVG objects (?) Cameras since ~2017 use a very limited OpenGL to better render graphics and menus.","title":"Firmware overview"},{"location":"rtos/#technical-overview-of-fujifilms-firmware","text":"(These details come from reverse-engineering the firmware of the X-A2.) Fujifilm started working on their firmware in the early 2000s. Instead of writing their firmware directly on an RTOS, they made a compatibility layer over an existing RTOS. This allowed them to easily switch from VxWorks to NORTi and to ThreadX over the years. Each function in Fuji's compatibility layer calls a specific index of a function table, which makes reverse engineering or using the underlying RTOS very difficult. Instead, this project aims to reverse engineer only Fujifilm's compatibility layer instead.","title":"Technical overview of Fujifilm's Firmware"},{"location":"rtos/#fujifilms-io-api","text":"See ff_io.h","title":"Fujifilm's I/O API"},{"location":"rtos/#memory-management","text":"Unlike most firmware, Fujifilm doesn't have a malloc() function. Each task works with fixed empty arrays. The developers created huge global variables. This means a lot of RAM is wasted, and it makes it harder to load Fujihack. There are some allocation functions, such as the ones from SQLite or the WiFi code, but these only offer a megabyte or two and don't take advantage of all the RAM the camera has (1GB). This unusual memory management has both pros and cons for the Fujihack project. - Patching data is easier - since everything is a global variable, a fixed address can be used to specify any data - It's hard to load a large Fujihack binary - Since memory can't be easily allocated, this makes it hard to find space to load Fujihack. Overall, it's not a deal breaker. Fujifilm managed to make it work over the years, and Fujihack can find ways around it.","title":"Memory management"},{"location":"rtos/#performance","text":"Fujifilm cameras up to 2016 are really slow. The CPU is underclocked to preserve battery life, which makes the camera sluggish sometimes. This doesn't take a toll on things like JPEG encoding and decoding, because it's done through hardware. The CPU performance of the X-A2 is similar to an i386 desktop computer of the mid 90s. After 2016, Fujifilm did something that improved performance. Or, at least the menu performance.","title":"Performance"},{"location":"rtos/#graphics","text":"Vector graphics processing is handled on vglib task Most cameras use OpenVG with the VG_KHR_EGL_image plugin. Implemented into Fuji cameras by NEC Systems Technology Ltd in the 2000s. The rst task renders the OpenVG objects (?) Cameras since ~2017 use a very limited OpenGL to better render graphics and menus.","title":"Graphics"},{"location":"signatures/","text":"RTOS Function signatures photo properties 02 00 a0 e3 00 10 a0 e1 1f 20 a0 e3 Typical Layout: int show_photo_properties(void) { char cVar1; byte bVar2; ushort uVar3; undefined4 uVar4; short sVar5; uint uVar6; int iVar7; int iVar8; undefined auStack60 [32]; uVar4 = DAT_X; iVar8 = *DAT_XX; cVar1 = *(char *)(DAT_XXX + 0xe754); if (cVar1 == 2) { fuji_rst_config1(0xf); fuji_rst_config2(10); lbl1: if (DAT_007b21ec[0x34b] != 0) { FUN_1(1,(DAT_007b21ec[0x34e] & 0xffffU) - 0x11 & 0xffff, (DAT_007b21ec[0x34f] & 0xffffU) - 0x11 & 0xffff, (DAT_007b21ec[0x34e] & 0xffffU) + 0x11 & 0xffff, (DAT_007b21ec[0x34f] & 0xffffU) + 0x11 & 0xffff,2,0x47); goto lbl3; } lbl2: if (cVar1 == 2) goto lbl3; } else { FUN_2(2, 2, 0x1f, 0x14, 0x12, 0, 0xcc); fuji_rst_config1(0xf); fuji_rst_config2(10); if (cVar1 == 1) { FUN_3(0x10, 2, 0xff000684); fuji_rst_write(2, 3, &DAT_STR_X); fuji_rst_write(0x10, 3, &DAT_STR_XX); usb plugged-in screen Function checks if a global integer is 0, 2, or 3. (signature will match more than 1 function) eb 05 00 a0 e3 01 10 a0 e3 Typical Layout: void usb_menu(void) { undefined4 uVar1; uVar1 = DAT_XXX; if (DAT_USB_MODE == '\\0') { FUN_1(); FUN_2(); DAT_USB_MODE = '\\x01'; } else { if (DAT_USB_MODE == '\\x02') { FUN_3(); } if (DAT_USB_MODE == '\\x03') { FUN_4(); fuji_rst_config1(0xd); fuji_rst_config2(10); FUN_5(2,1,0xff0008a6); FUN_6(5,1,0x7c0); FUN_7(); FUN_8(1,1,0x20,0x14,0x12,0,0xff); goto lbl; } } fuji_rst_config1(0xd); FUN_9(0x7c0,0,0xff0008a6,7,2,0x6d); FUN_10(1,1,0x20,0x14,0x12,0,0xff); lbl: fuji_rst_config1(uVar1); return; } Hints File IO Functions Look at WT_LOG and .MSG function For directory reading functions, look for \"*.*\" Calls are generally ordered as wait(), FIO call, wait(), reset() wait() and reset() get access to the SD card, and wait for system operations to pause msleep script WAIT and WAIT_SET code SQLite init function Look for unusual SQL code formatting, ( \"FFDB\" ) Flash reading functions Look for syslog dmain and de Multithreading System task function seems to be context sensitive Look for \"SoftTimerStart\" and \"SoftTimerStop\" EEPRom Look for most used functions, will modify a byte at an address fuji_apply_eeprom() is in \"eeprom setting menu\" Debug messages fuji_screen_write() is found in \"EEPRom Setting Mode\" fuji_discard_text_buffer() is found near that call","title":"Function signatures"},{"location":"signatures/#rtos-function-signatures","text":"","title":"RTOS Function signatures"},{"location":"signatures/#photo-properties","text":"02 00 a0 e3 00 10 a0 e1 1f 20 a0 e3 Typical Layout: int show_photo_properties(void) { char cVar1; byte bVar2; ushort uVar3; undefined4 uVar4; short sVar5; uint uVar6; int iVar7; int iVar8; undefined auStack60 [32]; uVar4 = DAT_X; iVar8 = *DAT_XX; cVar1 = *(char *)(DAT_XXX + 0xe754); if (cVar1 == 2) { fuji_rst_config1(0xf); fuji_rst_config2(10); lbl1: if (DAT_007b21ec[0x34b] != 0) { FUN_1(1,(DAT_007b21ec[0x34e] & 0xffffU) - 0x11 & 0xffff, (DAT_007b21ec[0x34f] & 0xffffU) - 0x11 & 0xffff, (DAT_007b21ec[0x34e] & 0xffffU) + 0x11 & 0xffff, (DAT_007b21ec[0x34f] & 0xffffU) + 0x11 & 0xffff,2,0x47); goto lbl3; } lbl2: if (cVar1 == 2) goto lbl3; } else { FUN_2(2, 2, 0x1f, 0x14, 0x12, 0, 0xcc); fuji_rst_config1(0xf); fuji_rst_config2(10); if (cVar1 == 1) { FUN_3(0x10, 2, 0xff000684); fuji_rst_write(2, 3, &DAT_STR_X); fuji_rst_write(0x10, 3, &DAT_STR_XX);","title":"photo properties"},{"location":"signatures/#usb-plugged-in-screen","text":"Function checks if a global integer is 0, 2, or 3. (signature will match more than 1 function) eb 05 00 a0 e3 01 10 a0 e3 Typical Layout: void usb_menu(void) { undefined4 uVar1; uVar1 = DAT_XXX; if (DAT_USB_MODE == '\\0') { FUN_1(); FUN_2(); DAT_USB_MODE = '\\x01'; } else { if (DAT_USB_MODE == '\\x02') { FUN_3(); } if (DAT_USB_MODE == '\\x03') { FUN_4(); fuji_rst_config1(0xd); fuji_rst_config2(10); FUN_5(2,1,0xff0008a6); FUN_6(5,1,0x7c0); FUN_7(); FUN_8(1,1,0x20,0x14,0x12,0,0xff); goto lbl; } } fuji_rst_config1(0xd); FUN_9(0x7c0,0,0xff0008a6,7,2,0x6d); FUN_10(1,1,0x20,0x14,0x12,0,0xff); lbl: fuji_rst_config1(uVar1); return; }","title":"usb plugged-in screen"},{"location":"signatures/#hints","text":"","title":"Hints"},{"location":"signatures/#file-io-functions","text":"Look at WT_LOG and .MSG function For directory reading functions, look for \"*.*\" Calls are generally ordered as wait(), FIO call, wait(), reset() wait() and reset() get access to the SD card, and wait for system operations to pause","title":"File IO Functions"},{"location":"signatures/#msleep","text":"script WAIT and WAIT_SET code","title":"msleep"},{"location":"signatures/#sqlite-init-function","text":"Look for unusual SQL code formatting, ( \"FFDB\" )","title":"SQLite init function"},{"location":"signatures/#flash-reading-functions","text":"Look for syslog dmain and de","title":"Flash reading functions"},{"location":"signatures/#multithreading","text":"System task function seems to be context sensitive Look for \"SoftTimerStart\" and \"SoftTimerStop\"","title":"Multithreading"},{"location":"signatures/#eeprom","text":"Look for most used functions, will modify a byte at an address fuji_apply_eeprom() is in \"eeprom setting menu\"","title":"EEPRom"},{"location":"signatures/#debug-messages","text":"fuji_screen_write() is found in \"EEPRom Setting Mode\" fuji_discard_text_buffer() is found near that call","title":"Debug messages"},{"location":"structure/","text":"Fujihack project structure Quick overview of Fujihack's code structure: src/ POSIX/Frontier compliant compatibility layer over Fujifilm's proprietary OS Header files defining Fujifilm's proprietary OS API ( ff_ ) frontier/ Submodule to Frontier. You can learn more about the project here . patch/ ARM32 assembly patches inserted directly into firmware. The patcher pulls files from this directory. ptp/ PTP/USB utility for running code with the code execution patch. Can also quickly load the fujihack binary. model/ Each camera model that has been reverse-engineered has its own C header file. It holds information on the camera, including important addreses (stubs) in memory, firmware, and other important model-specific information. Each file is named with the model code \"xf1\", \"xt4\", etc. Then an underscore, and the version code of the firmware that was analyzed. For example, if the version is \"1.01\", then the version code would be \"101\". See template.h for a basic example. Memory addresses start with MEM_ , firmware addresses start with FIRM_ , and functions are defined with the NSTUB macro.","title":"Project Structure"},{"location":"structure/#fujihack-project-structure","text":"Quick overview of Fujihack's code structure:","title":"Fujihack project structure"},{"location":"structure/#src","text":"POSIX/Frontier compliant compatibility layer over Fujifilm's proprietary OS Header files defining Fujifilm's proprietary OS API ( ff_ )","title":"src/"},{"location":"structure/#frontier","text":"Submodule to Frontier. You can learn more about the project here .","title":"frontier/"},{"location":"structure/#patch","text":"ARM32 assembly patches inserted directly into firmware. The patcher pulls files from this directory.","title":"patch/"},{"location":"structure/#ptp","text":"PTP/USB utility for running code with the code execution patch. Can also quickly load the fujihack binary.","title":"ptp/"},{"location":"structure/#model","text":"Each camera model that has been reverse-engineered has its own C header file. It holds information on the camera, including important addreses (stubs) in memory, firmware, and other important model-specific information. Each file is named with the model code \"xf1\", \"xt4\", etc. Then an underscore, and the version code of the firmware that was analyzed. For example, if the version is \"1.01\", then the version code would be \"101\". See template.h for a basic example. Memory addresses start with MEM_ , firmware addresses start with FIRM_ , and functions are defined with the NSTUB macro.","title":"model/"},{"location":"syslog/","text":"Syslog Syslog is a logging mechanism that records important system info and errors to RAM Typically, syslog Ver 2.3 is printed on startup. Log start addr typically is saved at addr 0x400a0400 Each log is 16 bytes The log string has no null terminator (easy to confuse with compressed ROM) First log / info struct struct Initial { char msg[0x14]; // only this is null terminated uint16_t of_0x14; uint8_t of_0x16; uint8_t of_0x17; uint16_t of_0x18; uint16_t of_0x1a; uint16_t of_0x1c_curr_msg; // ... uint32_t of_30; // end }; Each log struct log { // addressed in uint32_t and uint8_t form uint8_t type; (0xf == signal, 0x72 == string msg ) uint8_t of_1_ret_from_thread; uint8_t of_2; // val @ fffa9c08 uint8_t of_3; // 0 uint32_t id; // magic number?? char msg[8]; } Log text Most of the logs are abbreviations since only 8 bytes is allowed per log. A B ENCD Encoder RW Raw SHA Shade STRM Stream FUL Full","title":"Syslog"},{"location":"syslog/#syslog","text":"Syslog is a logging mechanism that records important system info and errors to RAM Typically, syslog Ver 2.3 is printed on startup. Log start addr typically is saved at addr 0x400a0400 Each log is 16 bytes The log string has no null terminator (easy to confuse with compressed ROM)","title":"Syslog"},{"location":"syslog/#first-log-info-struct","text":"struct Initial { char msg[0x14]; // only this is null terminated uint16_t of_0x14; uint8_t of_0x16; uint8_t of_0x17; uint16_t of_0x18; uint16_t of_0x1a; uint16_t of_0x1c_curr_msg; // ... uint32_t of_30; // end };","title":"First log / info struct"},{"location":"syslog/#each-log","text":"struct log { // addressed in uint32_t and uint8_t form uint8_t type; (0xf == signal, 0x72 == string msg ) uint8_t of_1_ret_from_thread; uint8_t of_2; // val @ fffa9c08 uint8_t of_3; // 0 uint32_t id; // magic number?? char msg[8]; }","title":"Each log"},{"location":"syslog/#log-text","text":"Most of the logs are abbreviations since only 8 bytes is allowed per log. A B ENCD Encoder RW Raw SHA Shade STRM Stream FUL Full","title":"Log text"},{"location":"tasks/","text":"Tasks for each model Each model has different task IDs XF1 task list X-A2 task list","title":"Tasks"},{"location":"tasks/#tasks-for-each-model","text":"Each model has different task IDs XF1 task list X-A2 task list","title":"Tasks for each model"},{"location":"tasks_xa2/","text":"Autogenerated by ripping ghidra C export Task ID Task Name 0x24 usb 6 delay 9 timer 0x50 flashext * execcpu 8 calendar 10 flash 0x25 keytimer 0x62 lenscom 100 lensdata 99 lswatch 0x28 graphic 0x22 lcdevf 0x49 vglib 0x1e soundio 0x1d voicecont 0x29 audio 0x1c media 0x66 mediamsg 0x3c flashloader 0x5f elfloader 0x3b initcont 0x32 lensdc 0x47 smaphp 0x47 smaphp 4 playcont 3 reccont 2 syscont 7 usbcont 1 ui 0x23 mujin 0x2b saclac 0x2d calc1 0x2e calcsub 0x2f imgdc 0x30 movdc 0x41 chase 0x42 mdetect 0x31 movrsz 0x40 rplib 0x3e facerecog 0x38 redeye 0x21 uilib 0x1f playsub 0x20 wificont 0x3f searchTbl 0x4a pm 0x4b pm 0x4c pm 0x4d pm 0x4e pm 0x4f pm 0x46 Facebook 0x57 netdrvsub 0x56 netdrv","title":"Tasks xa2"},{"location":"tasks_xf1/","text":"Task List ID Name Desc 0x2a zoom ... 0x37 rplib ... 0x23 saclac ... 0x32 initcont Responsible for IO? 0x1b mujin \"unpopulated\" in Japanese. Responsible for AUTO_ACT.SCR 0x17 soundio ... 0x16 voicecont ... 0x14 comp ... 0x57 root ... 0x55 idle0 ... 0x56 idle1 ... 0x52 standby1 ... 0x44 pm_dsp ... 0x3b book ... 0x29 lensdc ... 0x3d iwayagrelease ... 0x2f redeye ... 0x38 chase ... 0x3a hdmi ... 0x35 facerecog ... 0x26 calcsub ... 0x3e vglib ... 0x20 graphic ... 0x5 beep ... 0x54 elfloader ... 0x39 mdetect ... 0x2b focus ... 0x15 media Responsible for fopen, fwrite. Events are sent to this task 0x30 imgstabi ... 0x3f pm_snd ... 0x24 calc ... 0x40 pm_frm ... 0x36 searchTbl SQLite task 0x19 uilib Rasterizer code, responsible for show_photo_properties 0x6 delay ... 0x8 calendar ... 0x1d keytimer ... 0x4 playcont ... 0x21 audio ... 0x9 timer ... 0x42 pm_dcn ... 0x3c iwagdispatch ... 0x3 reccont ... 0x1c usb Manages PTP/USB 0x33 flashloader Loads in flash memory 0x7 usbcont Manages system tasks/UI when USB is plugged in 0x1/0x2? execcpu Task ID is loaded from memory 0x13 dpof Digital Print Order Format 0x2c iris ... 0xa flash Responsible for pop out flash + flash charging 0x18 playsub ... 0x28 movdc ... 0x43 pm_rsz ... 0x41 pm_dec ... 0x2 syscont ... 0x25 calc1 ... 0x27 imgdc ... 0x7 face ... 0x1f levelsens ... 0x1a lcdevf ... 0x1 ui ...","title":"Tasks xf1"},{"location":"tasks_xf1/#task-list","text":"ID Name Desc 0x2a zoom ... 0x37 rplib ... 0x23 saclac ... 0x32 initcont Responsible for IO? 0x1b mujin \"unpopulated\" in Japanese. Responsible for AUTO_ACT.SCR 0x17 soundio ... 0x16 voicecont ... 0x14 comp ... 0x57 root ... 0x55 idle0 ... 0x56 idle1 ... 0x52 standby1 ... 0x44 pm_dsp ... 0x3b book ... 0x29 lensdc ... 0x3d iwayagrelease ... 0x2f redeye ... 0x38 chase ... 0x3a hdmi ... 0x35 facerecog ... 0x26 calcsub ... 0x3e vglib ... 0x20 graphic ... 0x5 beep ... 0x54 elfloader ... 0x39 mdetect ... 0x2b focus ... 0x15 media Responsible for fopen, fwrite. Events are sent to this task 0x30 imgstabi ... 0x3f pm_snd ... 0x24 calc ... 0x40 pm_frm ... 0x36 searchTbl SQLite task 0x19 uilib Rasterizer code, responsible for show_photo_properties 0x6 delay ... 0x8 calendar ... 0x1d keytimer ... 0x4 playcont ... 0x21 audio ... 0x9 timer ... 0x42 pm_dcn ... 0x3c iwagdispatch ... 0x3 reccont ... 0x1c usb Manages PTP/USB 0x33 flashloader Loads in flash memory 0x7 usbcont Manages system tasks/UI when USB is plugged in 0x1/0x2? execcpu Task ID is loaded from memory 0x13 dpof Digital Print Order Format 0x2c iris ... 0xa flash Responsible for pop out flash + flash charging 0x18 playsub ... 0x28 movdc ... 0x43 pm_rsz ... 0x41 pm_dec ... 0x2 syscont ... 0x25 calc1 ... 0x27 imgdc ... 0x7 face ... 0x1f levelsens ... 0x1a lcdevf ... 0x1 ui ...","title":"Task List"},{"location":"todo/","text":"Low Hanging Fruit Things needed as of September 2023 Improve patcher HTML/CSS Make patcher use JS Classes instead of JSON Objects Write an emulator for Fuji emulator - everything is there in the firmware file - just need to map out the I/O Motherboard screenshots Test a custom firmware Index and data-hoard all Fujifilm firmware files","title":"Help Needed"},{"location":"todo/#low-hanging-fruit","text":"Things needed as of September 2023 Improve patcher HTML/CSS Make patcher use JS Classes instead of JSON Objects Write an emulator for Fuji emulator - everything is there in the firmware file - just need to map out the I/O Motherboard screenshots Test a custom firmware Index and data-hoard all Fujifilm firmware files","title":"Low Hanging Fruit"},{"location":"words/","text":"Camera Reverse Engineering Acronyms Cheat Sheet Name Desc PTP Picture Transfer Protocol MTP Media Transfer Protocol RTOS Real Time Operating System DPS Digital Photo Solutions for Imaging Devices SICD USB Still Image Capture Device DPOF Digital Print Order Format DCF Design rule for Camera File system DSTH DS Therm? EEP EEPROM RTC Real Time Clock SDIO Secure Digital Input Output (https://en.wikipedia.org/wiki/SD_card#SDIO_cards) DSC Digital Still Camera AP (Wireless) Access Point IC Indicator RST Rasterizer RSSI Received Signal Strength Indicator IEEE Wireless communications standard BSS Block starting symbol, uninitialized global arrays/data TMOUT Timeout WLD Wireless LAN Device? DSCF Digital Storage Compact Flash","title":"Vocabulary"},{"location":"words/#camera-reverse-engineering-acronyms-cheat-sheet","text":"Name Desc PTP Picture Transfer Protocol MTP Media Transfer Protocol RTOS Real Time Operating System DPS Digital Photo Solutions for Imaging Devices SICD USB Still Image Capture Device DPOF Digital Print Order Format DCF Design rule for Camera File system DSTH DS Therm? EEP EEPROM RTC Real Time Clock SDIO Secure Digital Input Output (https://en.wikipedia.org/wiki/SD_card#SDIO_cards) DSC Digital Still Camera AP (Wireless) Access Point IC Indicator RST Rasterizer RSSI Received Signal Strength Indicator IEEE Wireless communications standard BSS Block starting symbol, uninitialized global arrays/data TMOUT Timeout WLD Wireless LAN Device? DSCF Digital Storage Compact Flash","title":"Camera Reverse Engineering Acronyms Cheat Sheet"}]}